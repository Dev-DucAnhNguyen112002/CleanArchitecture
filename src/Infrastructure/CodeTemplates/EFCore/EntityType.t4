<#@ template hostSpecific="true" #>
<#@ assembly name="Microsoft.EntityFrameworkCore" #>
<#@ assembly name="Microsoft.EntityFrameworkCore.Design" #>
<#@ assembly name="Microsoft.EntityFrameworkCore.Relational" #>
<#@ assembly name="Microsoft.Extensions.DependencyInjection.Abstractions" #>
<#@ parameter name="EntityType" type="Microsoft.EntityFrameworkCore.Metadata.IEntityType" #>
<#@ parameter name="Options" type="Microsoft.EntityFrameworkCore.Scaffolding.ModelCodeGenerationOptions" #>
<#@ parameter name="NamespaceHint" type="System.String" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.ComponentModel.DataAnnotations" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="Microsoft.EntityFrameworkCore" #>
<#@ import namespace="Microsoft.EntityFrameworkCore.Design" #>
<#@ import namespace="Microsoft.Extensions.DependencyInjection" #>
<#
    if (EntityType.IsSimpleManyToManyJoinEntityType())
    {
        // Don't scaffold these
        return "";
    }

    var services = (IServiceProvider)Host;
    var annotationCodeGenerator = services.GetRequiredService<IAnnotationCodeGenerator>();
    var code = services.GetRequiredService<ICSharpHelper>();

    var usings = new List<string>
    {
        "System",
        "System.Collections.Generic",
        "CleanArchitectureTest.Domain.Common" // Namespace chứa các lớp Base
    };

    if (Options.UseDataAnnotations)
    {
        usings.Add("System.ComponentModel.DataAnnotations");
        usings.Add("System.ComponentModel.DataAnnotations.Schema");
        usings.Add("Microsoft.EntityFrameworkCore");
    }
    // ===== Manual config =====
    // Các entity KHÔNG dùng audit => Kế thừa BaseEntity (chỉ có Id)
    var NoAuditEntities = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
    {
        // "TenBangKhongAudit1",
        // "TenBangKhongAudit2",
    };
    // Các entity KHÔNG kế thừa base nào cả (không BaseEntity, không BaseAuditableEntity)
    var NoBaseEntities = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
    {
         //"UserRole",
         //"DiaPhanXa",
         //"PermissionType"
    };
    // Xác định base class theo cấu hình
    string? ResolveBaseClass(string entityName)
    {
        if (NoBaseEntities.Contains(entityName)) return null; // không kế thừa gì
        if (NoAuditEntities.Contains(entityName)) return "BaseEntity"; // chỉ Id
        return "BaseAuditableEntity"; // mặc định có audit
    }
    var baseClass = ResolveBaseClass(EntityType.Name);
    // Danh sách các property đã có trong BaseAuditableEntity / BaseEntity tuỳ theo baseClass
    var baseProperties = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
    if (string.Equals(baseClass, "BaseAuditableEntity", StringComparison.OrdinalIgnoreCase))
    {
        baseProperties = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
        {
            "Id", "Created", "CreatedBy", "LastModified", "LastModifiedBy"
        };
    }
    else if (string.Equals(baseClass, "BaseEntity", StringComparison.OrdinalIgnoreCase))
    {
        baseProperties = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
        {
            "Id"
        };
    }
     // Hàm helper để map kiểu dữ liệu
    string MapClrType(Microsoft.EntityFrameworkCore.Metadata.IProperty property)
    {
        var storeType = property.GetColumnType()?.ToLowerInvariant();
        
        // Chỉ xử lý mapping cho timestamptz
        if (storeType == "timestamptz" || storeType == "timestamp(6) with time zone" || storeType == "timestamp with time zone")
        {
            return "DateTimeOffset";
        }
        // Các trường hợp khác để nguyên
        return code.Reference(property.ClrType);
    }

    // Hàm helper để kiểm tra có phải timestamptz không
    bool IsTimestampTz(Microsoft.EntityFrameworkCore.Metadata.IProperty property)
    {
        var storeType = property.GetColumnType()?.ToLowerInvariant();
        return storeType == "timestamptz" || storeType == "timestamp(6) with time zone" || storeType == "timestamp with time zone";
    }
#>
<#
    if (!string.IsNullOrEmpty(NamespaceHint))
    {
#>
namespace <#= NamespaceHint #>;

<#
    }

    if (!string.IsNullOrEmpty(EntityType.GetComment()))
    {
#>
/// <summary>
/// <#= code.XmlComment(EntityType.GetComment()) #>
/// </summary>
<#
    }

    if (Options.UseDataAnnotations)
    {
        foreach (var dataAnnotation in EntityType.GetDataAnnotations(annotationCodeGenerator))
        {
#>
<#= code.Fragment(dataAnnotation) #>
<#
        }
    }
#>
public partial class <#= EntityType.Name #><#= baseClass != null ? " : " + baseClass : "" #>
{
<#
    var firstProperty = true;
    foreach (var property in EntityType.GetProperties().OrderBy(p => p.GetColumnOrder() ?? -1))
    {
        if (baseProperties.Contains(property.Name))
        {
            continue; // Bỏ qua property đã có trong base class
        }
        if (!firstProperty)
        {
            WriteLine("");
        }

        if (!string.IsNullOrEmpty(property.GetComment()))
        {
#>
    /// <summary>
    /// <#= code.XmlComment(property.GetComment(), indent: 1) #>
    /// </summary>
<#
        }

        if (Options.UseDataAnnotations)
        {
            var dataAnnotations = property.GetDataAnnotations(annotationCodeGenerator)
                .Where(a => !(a.Type == typeof(RequiredAttribute) && Options.UseNullableReferenceTypes && !property.ClrType.IsValueType));
            foreach (var dataAnnotation in dataAnnotations)
            {
#>
    <#= code.Fragment(dataAnnotation) #>
<#
            }
        }
        // Thêm namespace tương ứng nếu cần
        if (IsTimestampTz(property))
        {
            usings.Add("System");
        }
        else
        {
            usings.AddRange(code.GetRequiredUsings(property.ClrType));
        }
        var isTimestampTz = IsTimestampTz(property);
        var needsNullable = Options.UseNullableReferenceTypes && property.IsNullable && !(isTimestampTz ? false : property.ClrType.IsValueType);
        var needsInitializer = Options.UseNullableReferenceTypes && !property.IsNullable && !(isTimestampTz ? false : property.ClrType.IsValueType);
        
        // Sử dụng hàm mapping tùy chỉnh
        var mappedType = MapClrType(property);
#>
    public <#= mappedType #><#= needsNullable ? "?" : "" #> <#= property.Name #> { get; set; }<#= needsInitializer ? " = null!;" : "" #>
<#
        firstProperty = false;
    }

    foreach (var navigation in EntityType.GetNavigations())
    {
        WriteLine("");

        if (Options.UseDataAnnotations)
        {
            foreach (var dataAnnotation in navigation.GetDataAnnotations(annotationCodeGenerator))
            {
#>
    <#= code.Fragment(dataAnnotation) #>
<#
            }
        }

        var targetType = navigation.TargetEntityType.Name;
        if (navigation.IsCollection)
        {
#>
    public virtual ICollection<<#= targetType #>> <#= navigation.Name #> { get; set; } = new List<<#= targetType #>>();
<#
        }
        else
        {
            var needsNullable = Options.UseNullableReferenceTypes && !(navigation.ForeignKey.IsRequired && navigation.IsOnDependent);
            var needsInitializer = Options.UseNullableReferenceTypes && navigation.ForeignKey.IsRequired && navigation.IsOnDependent;
#>
    public virtual <#= targetType #><#= needsNullable ? "?" : "" #> <#= navigation.Name #> { get; set; }<#= needsInitializer ? " = null!;" : "" #>
<#
        }
    }

    foreach (var skipNavigation in EntityType.GetSkipNavigations())
    {
        WriteLine("");

        if (Options.UseDataAnnotations)
        {
            foreach (var dataAnnotation in skipNavigation.GetDataAnnotations(annotationCodeGenerator))
            {
#>
    <#= code.Fragment(dataAnnotation) #>
<#
            }
        }
#>
    public virtual ICollection<<#= skipNavigation.TargetEntityType.Name #>> <#= skipNavigation.Name #> { get; set; } = new List<<#= skipNavigation.TargetEntityType.Name #>>();
<#
    }
#>
}
<#
    var previousOutput = GenerationEnvironment;
    GenerationEnvironment = new StringBuilder();

    foreach (var ns in usings.Distinct().OrderBy(x => x, new NamespaceComparer()))
    {
#>
using <#= ns #>;
<#
    }

    WriteLine("");

    GenerationEnvironment.Append(previousOutput);
#>
